---
title: 详解Android插件框架 (二)--动态加载
date: 2018-06-26 22:15:49
tags:
toc_number: true
---

## 前言
什么是动态加载呢？简单来说就是当应用程序在运行时候，通过加载一些本地不存在的执行文件(或代码片段)来实现特定的功能。比如我们Android加载SO库或者dex文件。虽然一般情况下我们都把SO打包在Apk内部，但是其实我们还是可以从外部加载。而对于Dex文件也是同样的效果。

## Android中动态加载
理论来说我们可以直接加载这些外部的可执行库，但是由于Android系统出于安全的限制，动态加载这些外部库，必须将其先拷贝到data/packagename/内部储存文件路径，然后才能加载，原因是由于只有应用自己有权限访问data/packagename/ 该路径，所以也避免了其他程序恶意篡改这些外部库。
所以我们动态加载的过程基本就是：
> * 拷贝(SO/jar/dex/apk)到App私有目录
> * 加载可执行库
> * 调用需要的代码

基于这样的特性我们在做性能优化时候，可以考虑将不常用，体积较大的SO库不随Apk打包，而是通过用户主动下载并且使用。那么对于Dex文件也是可以如此，所以我们可以在提前在代码里留好加载外部Dex的接口然后通过动态下载Dex的方式使应用程序在安装以后，依然可以改变代码逻辑。看到这是不是开始浮想联翩，感觉无所不能了？别高兴的太早，其实这样的动态加载是有很大局限性的。没有想象那么自由！

## 动态加载的限制
### 资源限制
从上面讲解，我们可以知道，如果我们在应用运行时，使用动态加载外部的dex文件，我们无需重新安装应用，即可改变应用的中代码逻辑。但是事实是这只能改变逻辑部分的代码，你缺无法更改和UI资源相关的代码，比如你有一个图片需要图片需要替换，你在代码里是怎么写的呢？R.drawable.xxx，这个R.drawable.xxx是一个int值，这个值在Apk打包时候由aapt都打好了编号，如果你动态加载一段代码，这段代码中这个值你写多少呢？所以是无解。当然也有人说我可以把要用的资源都先放进Apk里面，这样当然可以，不过我觉得具体实现起来有些困难，而且无故增加了包的大小。

### Android组件限制
让我们回忆下刚学习Android开发时候，我相信很多同学都遇到过这个错误
```
Unable to find explicit activity class {com.example.xxx/com.example.xxx.ListActivity$Companion}; have you declared this activity in your AndroidManifest.xml?  
```
大家一看就知道，这就是Activity组件没有在AndroidManifest文件中注册导致的，其实不光Activity需要注册，四大组件都需要注册，那么问题来了，我们新写了一个Activity，就算里面没有用到任何资源，我们也无法动态加载去启动它，原因就是从来都没在AndroidManifest中注册过，那我们能不能动态改变AndroidManifest这个呢，说实话，不可能，因为AndroidManifest文件是在Apk安装时候，被系统PMS(PackageManagerService)读取并且记录的，安装完后，PMS不会再去读取应用AndroidManifest文件。所以除非我们重装APP，否则没法解决这个问题。所以不能动态更新四大组件。

## Android 热补丁
其实Android的热补丁技术就是我们上面说的动态加载技术的原理，我们也看到了其局限性很大，对于一般的逻辑bug修复，热补丁可以很好的解决，避免应用重新安装，但是对于模块(组件+资源)的更新，热补丁技术就显得有点乏力。正是因为这样的原因，插件框架才被研究出来，弥补热补丁的不足，给程序员更大动态加载权限。

## 结语
本篇文章主要给大家温习一下Android的动态加载技术，作为插件框架的理论基础，我们可以看到在Android中是支持动态加载的，问题是支持的不够Open，很多东西还藏着掖着。下一篇文章，我们来主要看看类加载器Classload ，了解了它，我们才能更好的掌握动态加载的原理。[《详解Android插件框架 (三) --- 类加载大管家Classload》